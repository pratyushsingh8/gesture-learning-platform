<!-- templates/sketch.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sketch Game — Draw with Hand</title>
  <style>
    :root{
      --card-bg: #fff;
      --accent: #ffb74d;
      --muted: #f6e7d6;
      --shadow: 0 8px 30px rgba(0,0,0,0.08);
      --brand: #ff8a65;
    }
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Arial,sans-serif;background:linear-gradient(135deg,#fff7e6,#ffd8b1)}
    .wrap{max-width:1200px;margin:28px auto;padding:12px}
    .box{display:grid;grid-template-columns:1fr 320px;gap:18px;background:var(--card-bg);border-radius:14px;padding:14px;box-shadow:var(--shadow);}

    /* LEFT: canvas area */
    .left{position:relative;border-radius:10px;overflow:hidden;background:#fff;padding:12px;border:4px solid rgba(255,183,77,0.15)}
    #drawCanvas{display:block;width:100%;height:720px;background:white;border-radius:8px;box-sizing:border-box}

    /* small preview (camera overlay) */
    .preview-wrap{position:absolute;right:18px;top:18px;width:260px;height:180px;border-radius:10px;overflow:hidden;background:#111;display:flex;align-items:center;justify-content:center;color:#fff}
    .preview-wrap.hidden{display:none}
    .preview-wrap .hint{font-size:0.95rem;opacity:0.9;text-align:center;padding:8px}
    canvas.output_canvas{width:100%;height:100%;display:block}
    /* Position preview top-right over drawing canvas */
canvas.output_canvas {
  position: absolute;
  right: 10px;
  top: 10px;
  width: 280px;
  height: 210px;
  border-radius: 10px;
  background: #111; /* fallback background when camera off */
  display: block;
}
    /* RIGHT: controls */
    .controls{padding:6px}
    h3{margin:6px 0 12px 0;color:#222}
    .controls .row{display:flex;gap:12px;margin-bottom:10px;flex-wrap:wrap}
    button{background:var(--accent);border:none;padding:10px 12px;border-radius:10px;font-weight:700;cursor:pointer;box-shadow:0 4px rgba(0,0,0,0.06)}
    .small{padding:8px 10px}
    .muted{background:var(--muted)}
    select{padding:8px;border-radius:8px;border:1px solid #e9d6c0}
    .status{margin-top:12px;font-weight:700}
    .legend{margin-top:14px;font-size:0.95rem}
    .legend li{margin-bottom:6px}

    /* responsive */
    @media (max-width: 980px){
      .box{grid-template-columns:1fr;}
      #drawCanvas{height:520px}
      .preview-wrap{position:relative;width:100%;height:160px;right:auto;top:auto;margin-top:10px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="box">
      <div class="left">
        <canvas id="drawCanvas" width="800" height="600"></canvas>
        <video id="input_video" style="display:none;" playsinline></video>
        <!-- camera preview area (shows placeholder when camera is off) -->
        <div id="previewPlaceholder" class="preview-wrap">
          <div class="hint">Camera preview<br>Press <b>Start Camera</b></div>
        </div>

        <canvas class="output_canvas" width="320" height="240" ></canvas>
      </div>

      <div class="controls">
        <h3>Sketch Game — Draw with Hand</h3>
        <div class="row">
          <button id="startBtn">Start Camera</button>
          <button id="stopBtn" class="small muted">Stop Camera</button>
          <button id="clearBtn" class="small">Clear</button>
        </div>

        <div class="row">
          <button id="recognizeBtn">Recognize Shape (manual)</button>
          <button id="saveBtn" class="small muted">Save Sample</button>
          <select id="sampleLabel"><option value="circle">circle</option><option value="square">square</option><option value="triangle">triangle</option><option value="rectangle">rectangle</option></select>
        </div>

        <div class="status">
          <div id="modeLabel">Mode: Camera Off</div>
          <div id="gestureLabel">Gesture: -</div>
          <div id="recognizeResult">Result: -</div>
        </div>

        <ul class="legend">
          <li><b>Index finger</b> — draw</li>
          <li><b>Fist</b> — erase</li>
          <li><b>Index + Middle</b> — hold to recognize (~0.8s)</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- MediaPipe scripts -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

  <script>
    // elements
    const startBtn = document.getElementById('startBtn');
    const stopBtn  = document.getElementById('stopBtn');
    const clearBtn = document.getElementById('clearBtn');
    const recognizeBtn = document.getElementById('recognizeBtn');
    const saveBtn = document.getElementById('saveBtn');
    const sampleLabel = document.getElementById('sampleLabel');

    const previewPlaceholder = document.getElementById('previewPlaceholder');
    const canvasOverlay = document.querySelector('.output_canvas');
    const overlayCtx = canvasOverlay.getContext('2d');

    const canvas = document.getElementById('drawCanvas');
    const ctx = canvas.getContext('2d');

    // initial drawing style
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.lineWidth = 8;
    ctx.strokeStyle = '#222';

    // MediaPipe + camera
    let camera;
    const hands = new Hands({ locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    hands.setOptions({ maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.6, minTrackingConfidence:0.6 });
    hands.onResults(onResults);

    const videoElement = document.createElement('video');
    videoElement.setAttribute('playsinline', 'true');

    // drawing state
    let prev = null; let drawing = false; let erasing = false;
    let holdStart = null; let holdThreshold = 800; let recognizingLocked = false;

    // keep the canvas crisp on high-DPI displays
    function resizeCanvasToDisplaySize() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      // set internal pixel size
      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);
      // set transform so drawing coordinates are in CSS pixels (not device pixels)
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    // utilities for finger states
    function getFingerStates(landmarks){
      const tips=[4,8,12,16,20];
      const pips=[2,6,10,14,18];
      const s=[];
      for (let i=0;i<5;i++) s.push(landmarks[tips[i]].y < landmarks[pips[i]].y);
      return {thumb:s[0], index:s[1], middle:s[2], ring:s[3], pinky:s[4]};
    }

    // start/stop camera
    function startCamera(){
      previewPlaceholder.classList.add('hidden');
      canvasOverlay.style.display = 'block';
      canvasOverlay.width = 320; canvasOverlay.height = 180;
      camera = new Camera(videoElement, { onFrame: async ()=> await hands.send({image: videoElement}), width:640, height:480 });
      camera.start();
      document.getElementById('modeLabel').innerText = 'Mode: Camera On';
    }

    function stopCamera(){
      if (camera) camera.stop();
      canvasOverlay.style.display = 'none';
      previewPlaceholder.classList.remove('hidden');
      document.getElementById('modeLabel').innerText = 'Mode: Camera Off';
    }

    function clearCanvas(){
      // clear in device-space safely
      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.restore();
      document.getElementById('recognizeResult').innerText='Result: -';
    }

    function onResults(results){
      // draw camera overlay
      overlayCtx.clearRect(0,0,canvasOverlay.width, canvasOverlay.height);
      if (results.image) overlayCtx.drawImage(results.image, 0, 0, canvasOverlay.width, canvasOverlay.height);

      if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0){
        prev=null; drawing=false; erasing=false; document.getElementById('gestureLabel').innerText='Gesture: none'; return;
      }

      const landmarks = results.multiHandLandmarks[0];
      drawConnectors(overlayCtx, landmarks, HAND_CONNECTIONS, {color:'#00FF00', lineWidth:2});
      drawLandmarks(overlayCtx, landmarks, {color:'#FF0000', lineWidth:1});

      const fs = getFingerStates(landmarks);
      document.getElementById('gestureLabel').innerText = `Gesture: idx:${fs.index} mid:${fs.middle}`;

      // map normalized tip to CSS coordinates using canvas bounding box
      const indexTip = landmarks[8];
      const rect = canvas.getBoundingClientRect();
      const x = indexTip.x * rect.width;
      const y = indexTip.y * rect.height;

      if (fs.index && !fs.middle){
        // draw
        drawing=true; erasing=false; document.getElementById('modeLabel').innerText='Mode: Drawing (index up)';
        ctx.globalCompositeOperation='source-over'; ctx.lineWidth=8; ctx.strokeStyle='#222';
        if (prev){ ctx.beginPath(); ctx.moveTo(prev.x, prev.y); ctx.quadraticCurveTo((prev.x+x)/2,(prev.y+y)/2,x,y); ctx.stroke(); }
        prev={x,y}; holdStart=null;
      } else if (!fs.index && !fs.middle && !fs.ring && !fs.pinky){
        // fist -> erase
        erasing=true; drawing=false; document.getElementById('modeLabel').innerText='Mode: Erasing (fist)';
        ctx.globalCompositeOperation='destination-out'; ctx.lineWidth=40;
        if (prev){ ctx.beginPath(); ctx.moveTo(prev.x, prev.y); ctx.lineTo(x,y); ctx.stroke(); }
        else { ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+0.1,y); ctx.stroke(); }
        prev={x,y}; holdStart=null;
      } else if (fs.index && fs.middle){
        // hold to recognize
        drawing=false; erasing=false; ctx.globalCompositeOperation='source-over'; document.getElementById('modeLabel').innerText='Mode: Hold to Recognize';
        if (!holdStart) holdStart = Date.now();
        else {
          const elapsed = Date.now() - holdStart;
          if (elapsed > holdThreshold && !recognizingLocked){
            recognizingLocked = true;
            runRecognition();
            setTimeout(()=>recognizingLocked=false,1500);
          }
        }
        prev = null;
      } else {
        // idle
        prev=null; drawing=false; erasing=false; holdStart=null; document.getElementById('modeLabel').innerText='Mode: Idle';
      }
    }

    // Send to backend for recognition
    async function runRecognition(){
      document.getElementById('recognizeResult').innerText='Result: recognizing...';
      const dataUrl = canvas.toDataURL('image/png');
      try {
        const r = await fetch('/api/recognize', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ image: dataUrl })
        });
        const result = await r.json();
        if (result.shape){
          document.getElementById('recognizeResult').innerText = 'Result: ' + result.shape;
          drawPerfectShape(result);
        } else {
          document.getElementById('recognizeResult').innerText = 'Result: unknown';
        }
      } catch (e) {
        console.error(e);
        document.getElementById('recognizeResult').innerText='Result: error';
      }
    }

    // manual hooks
    startBtn.addEventListener('click', ()=>{ resizeCanvasToDisplaySize(); startCamera(); });
    stopBtn.addEventListener('click', ()=>stopCamera());
    clearBtn.addEventListener('click', ()=>clearCanvas());
    recognizeBtn.addEventListener('click', ()=>runRecognition());

    saveBtn.addEventListener('click', async ()=>{
      const label = sampleLabel.value; const dataUrl = canvas.toDataURL('image/png');
      try{
        const r = await fetch('/api/save_sample',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({image:dataUrl,label})});
        const j = await r.json();
        alert('Saved: '+ j.path);
      }catch(e){ alert('Save failed'); }
    });

    // draw the perfect shape returned from server
    function drawPerfectShape(result){
      if (!result.shape) return;
      // clear canvas properly
      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.restore();

      ctx.globalCompositeOperation='source-over';
      ctx.lineWidth=6;
      ctx.strokeStyle='#1e88e5';
      ctx.fillStyle='rgba(30,136,229,0.06)';

      const rect = canvas.getBoundingClientRect();
      const cw = rect.width, ch = rect.height;

      if (result.shape === 'circle' && result.params){
        const cx = result.params.cx * cw;
        const cy = result.params.cy * ch;
        const r = result.params.r * Math.min(cw,ch);
        ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill(); ctx.stroke();
      } else if ((result.shape === 'square' || result.shape === 'rectangle') && result.params){
        const x = result.params.x * cw;
        const y = result.params.y * ch;
        const w = result.params.w * cw;
        const h = result.params.h * ch;
        ctx.beginPath(); ctx.rect(x,y,w,h); ctx.fill(); ctx.stroke();
      } else if (result.shape === 'triangle' && result.params){
        ctx.beginPath(); const pts = result.params.points.map(p => [p.x*cw, p.y*ch]);
        ctx.moveTo(pts[0][0],pts[0][1]); ctx.lineTo(pts[1][0],pts[1][1]); ctx.lineTo(pts[2][0],pts[2][1]); ctx.closePath();
        ctx.fill(); ctx.stroke();
      }
    }

    // initialize canvas resolution
    window.addEventListener('load', ()=>{ resizeCanvasToDisplaySize(); });
    window.addEventListener('resize', ()=>{ resizeCanvasToDisplaySize(); });

    // optional: auto start camera by uncommenting below
    // resizeCanvasToDisplaySize(); startCamera();
  </script>
</body>
</html>
